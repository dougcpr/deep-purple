import atexit
import asyncio
import sys

from freedomrobotics.helpers.jsonhelper import fastjson

if sys.version_info < (3, 6):
    raise Exception("This module must be run in Python3.6+")

loop = asyncio.get_event_loop_policy().get_event_loop()


class CommLinkClient:
    """
    This is  an async wrapper around the socket client to allow us  to call
    back to the main WebRTC Controller and communicate two ways

    """
    def __init__(self, name, logger, port, message_callback, disconnect_callback=None):
        self.name = name
        self.logger = logger
        self.port = port
        self.message_callback = message_callback
        self.disconnect_callback = disconnect_callback

        self.writer = None
        self.reader = None
        self.is_closed = False

        atexit.register(self.close)
        asyncio.ensure_future(self._connect(), loop=loop)

    async def send_message(self, message={}):
        """
        Send a message to the controller. It should  be a dictionary

        """
        if not isinstance(message, dict):
            raise Exception("Can only send dictionary messages: " + str(type(message)))

        message = fastjson.dumps(message) + "\n"

        if self.writer is not None:
            try:
                self.writer.write(message.encode('utf8'))
            except Exception as e:
                log_msg = "CommLink Client failed to send_message: {}".format(e)
                self.logger.exception(log_msg)
                self.close(reason=log_msg)
        else:
            raise Exception("CommLink Client is not connected so can not send a message to port " + str(self.port))

    def is_connected(self):
        """
        Returns true 
        """
        return self.writer is not None and self.reader is not None and not self.is_closed

    def close(self, reason='unknown'):
        reason += '(async client)'
        if self.is_closed is True:
            return

        self.is_closed = True

        if self.writer is not None:
            try:
                # Try to force close the other end
                self.writer.write_eof()
            except Exception as e:
                self.logger.exception("CommLink Client could not send EOF from client back to server: {}".format(e))
                
            try:
                self.writer.close()
                self.logger.info("    CommLink Client closed writer")
            except Exception as e:
                self.logger.exception("CommLink Client could not close writer: {}".format(e))
            finally:
                self.writer = None

        if self.disconnect_callback is not None:
            try:
                asyncio.ensure_future(self.disconnect_callback(reason=reason), loop=loop)
            except Exception as e:
                self.logger.exception("CommLink Client could not call disconnect_callback: {}".format(e))

        self.logger.info("CommLink Client is closed")

    async def _connect(self):
        self.logger.debug("Client attempting connection to Sync Server on port {}".format(self.port))
        self.reader, self.writer = await asyncio.open_connection('localhost', self.port)
        asyncio.ensure_future(self._listen_once(), loop=loop)

    async def _listen_once(self):
        """
        This is an async loop which calls itself to
        retrieve more commands
        """

        try:
            if self.is_closed:
                self.logger.info("CommLink connection is closed, so stopping client listening")
                return

            try:
                messages = await self.reader.readline()

                # self.logger.debug("MESSAGES RETURNED >>>>>>>> " + str(type(messages)) + " " + str(len(messages)) +
                # " " +  str(messages))

                if messages is None or len(messages) == 0:
                    self.logger.info("CommLink remote connection disconnected from " + self.name)
                    self.close()

                messages = messages.decode('utf-8')
                for message in messages.split("\n"):
                    if len(message) == 0:
                        continue
                    try:
                        message = fastjson.loads(message)
                        await self.message_callback(message)
                    except ValueError as e:
                        self.logger.error(
                            "CommLink Client could not parse message in listen_once: {}: {}".format(message, e))
                    await asyncio.sleep(0.001)
            except Exception as e:
                self.logger.exception('Exception raised in ComLink Client Async listen_once: {}'.format(e))
                self.logger.info("CommLink Client remote connection disconnected from " + self.name)
                self.close()
                return
            # This makes it non blocking for this loop.
            await asyncio.sleep(0.001)
            asyncio.ensure_future(self._listen_once(), loop=loop)
        except asyncio.CancelledError as e:
            # This is called when we cancel this task on close()
            pass
