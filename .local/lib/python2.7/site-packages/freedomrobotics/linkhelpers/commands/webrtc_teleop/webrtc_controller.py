#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (C) Freedom Robotics, 2019 - All Rights Reserved

This file is part of the the Freedom Python SDK

Unauthorized copying of this file, via any medium is strictly prohibited
Proprietary and confidential
"""
import os
import time
import subprocess
import threading
import traceback
import uuid

import SharedArray
import numpy as np
import six

from freedomrobotics.helpers import credentials as credentials_helper
from freedomrobotics.helpers import system_commands
from freedomrobotics.helpers.jsonhelper import replace_inf_nan_values, fastjson
from freedomrobotics.helpers.logging_helpers import setup_logging
from freedomrobotics.linkhelpers.commands.webrtc_teleop.comm_link_server_sync import CommLinkServer
from freedomrobotics.linkhelpers.commands.set_webrtc_video_topic import handle_image

COMM_LINK_SERVER_PORT = credentials_helper.load()[0].get('configuration', {}).get('webrtc_local_port', 5540)

PILOT_COMMANDS_TYPES = (
    'geometry_msgs/Twist', 'geometry_msgs/TwistStamped',
    'geometry_msgs/msg/Twist', 'geometry_msgs/msg/TwistStamped',
    'sensor_msgs/Joy', 'sensor_msgs/msg/Joy'
)

ALLOWED_COMMANDS_TYPES = PILOT_COMMANDS_TYPES + (
    'change_image_source',
)
# If we find non-zero velocity commands older than this threshold,
# we send a zero-velocity command to make sure the robot is stopped.
DEADMAN_DISCONNECT_THRESHOLD = 2


class WebRTC_Controller:
    """
    Interface which creates the WebRTC Process
    
    """

    VELOCITY_TYPES = [
        'geometry_msgs/Twist',
        'geometry_msgs/TwistStamped',
        'geometry_msgs/msg/Twist',
        'geometry_msgs/msg/TwistStamped',
    ]

    def __init__(self, link, fps):
        self.offer = None
        self.topic = None
        self.answer = None
        self.link = link
        self.logger = setup_logging(
            name=__name__,
            log_path=os.path.join(self.link.device_dir, 'logs', 'webrtc_sync.log'),
            log_level=self.link.credentials.get('log_level').upper(),
            log_format="%(asctime)s [ SYNC] [%(process)5d] [%(levelname)-5.5s]  %(message)s",
            console=False,
        )
        self.shared_array_image = None
        self.is_shutdown = False
        self.cmd_callback = None
        self.service_proc = None
        self.uploadable_topics = {}
        self.last_received_command_per_topic = {}
        if hasattr(self.link, 'webrtc_uploadable_topics'):
            self.uploadable_topics = self.link.webrtc_uploadable_topics
        self.min_frame_delay = 1.0/fps
        self.last_frame_time = time.time() - self.min_frame_delay
        self.last_received_frame_time = time.time() - self.min_frame_delay
        # leniency is how much time (in seconds) a frame can arrive early and still be accepted
        self.accept_frame_leniency = 0.0
        self.is_peer_connection_open = False

        # Start our actual WebRTC Process
        self.webrtc_server_thread = threading.Thread(target=self.launch_webrtc_server)
        self.webrtc_server_thread.daemon = True
        self.webrtc_server_thread.start()

        # start RPC server as a process in a separate thread
        self.logger.info('Creating CommLink SyncServer')
        self.comm_link_sync_server = CommLinkServer(
            "CommLink SyncServer",
            self.logger,
            COMM_LINK_SERVER_PORT,
            self.server_message_callback, 
            self.server_disconnect_callback,
        )

        # start the deadman-checker thread
        self.deadman_thread = threading.Thread(
            name="freedom_webrtc_deadman_check_thread",
            target=self.deadman_thread_main,
            args=(DEADMAN_DISCONNECT_THRESHOLD,)
        )
        self.deadman_thread.daemon = True
        self.deadman_thread.start()
        self.accept_frame_leniency = 0
        
        start_time = time.time()
        while time.time() - start_time < 15:
            if self.comm_link_sync_server is None:
                raise Exception("WebRTC controller was prematurely shut down.")
            elif self.comm_link_sync_server.is_connected():
                break
            time.sleep(0.1)
        else:
            shut_down_reason = 'Could not connect to WebRTC Server after 15 seconds.'
            self.shutdown(reason=shut_down_reason)
            raise Exception(shut_down_reason)

        self.logger.info("WebRTC Controller is complete and connected to the WebRTC Server")

    def server_message_callback(self, msg):
        """
        This is the default callback method for messages received by CommLink SyncServer,
         acts as a selector, calling the right method for each message
        :param msg:
        :return:
        """
        if 'method' not in msg:
            raise Exception("Received a message from the controller without a `method` element: " + fastjson.dumps(msg))

        if msg['method'] == 'received_link_command':
            self.received_link_command(msg)
        elif msg['method'] == 'update_fps':
            if 'fps' in msg:
                self.min_frame_delay = 1.0 / msg['fps']
        elif msg['method'] == 'received_webrtc_event':
            self.received_webrtc_event(msg)
        elif msg['method'] == 'on_error':
            self.on_error(msg)
        elif msg['method'] == 'set_answer':
            self.set_answer(msg)
        elif msg['method'] == 'ping':
            # Let them ping us to see if we are still around
            pass
        elif msg['method'] == 'unregister_image_topic':
            self.unregister_image_topic(msg.get('session'))
        elif msg['method'] == 'connection_lost':
            self.connection_lost(msg.get('session'), reason=msg.get('reason'))
        elif msg['method'] == 'shutdown':
            self.shutdown(reason=msg.get('reason'))
        else:
            raise Exception("Unknown message from server: " + fastjson.dumps(msg))

    def deadman_thread_main(self, threshold):
        """
        This is the main loop of the deadman-checker thread.
        Every second it checks the last seen messages, and if it detects a nonzero velocity coomand
        that is older than a threshold, it send a zero-velocity command to make sure the
        robot stops.
        """
        try:
            while not self.is_shutdown:
                time.sleep(1)
                now = time.time()
                # for each seen topic, check last message
                for topic, message in self.last_received_command_per_topic.items():
                    command = message['command']

                    # if the last velocity command is older than threshold, we need to check
                    if command['type'] in self.VELOCITY_TYPES and now - message['utc_secs'] > threshold:

                        # --- check last command's velocity
                        if 'Stamped' in command['type']:
                            linear = command['message']['twist']['linear']
                            angular = command['message']['twist']['angular']
                        else:
                            linear = command['message']['linear']
                            angular = command['message']['angular']
                        # if the last command is all zeros we don't need to do anything.
                        if linear == {'x': 0, 'y': 0, 'z': 0} and angular == {'x': 0, 'y': 0, 'z': 0}:
                            continue
                        # ---

                        # send 0-velocity command
                        self.logger.warning((
                            'Found a non-zero velocity command that is older than {} seconds, '
                            'this probably means that the WebRTC connection is lost. '
                            'Sending zero-velocity command to topic: "{}" '
                            'to make sure the robot is stopped.'
                        ).format(threshold, topic))

                        new_command = command.copy()
                        if 'Stamped' in command['type']:
                            new_command['message']['twist']['linear'] = {'x': 0, 'y': 0, 'z': 0}
                            new_command['message']['twist']['angular'] = {'x': 0, 'y': 0, 'z': 0}
                        else:
                            new_command['message']['linear'] = {'x': 0, 'y': 0, 'z': 0}
                            new_command['message']['angular'] = {'x': 0, 'y': 0, 'z': 0}
                        # make sure time and uid are new and unique so link don't discard the message
                        new_command['utc_time'] = time.time()
                        new_command['uid'] = six.text_type(uuid.uuid4())
                        self.received_link_command({'command': new_command})
        except Exception as e:
            self.on_error(
                "Exception on WebRTC deadman_thread_main: {}".format(e),
                traceback.format_exc()
            )

    def server_disconnect_callback(self):
        """
        Method called when CommLink SyncServer losses connection from the ASYNC Client
        will trigger shutdown on all WebRTC components.
        :return:
        """
        self.logger.info('WebRTC Controller Server disconnected')
        self.shutdown(reason='CommLink ASyncClient disconnected from SyncServer')

    def launch_webrtc_server(self):
        """
        This method is in charge of launching the external WebRTC Server process `fr_webrtc`, waiting for its execution
        :return:
        """
        start_time = time.time()
        self.logger.debug("Starting ASYNC WebRTC Server ...")
        python3_path = self.link.credentials.get('python3', 'python3')
        launch_cmd = [python3_path, "-B", "-m", "freedomrobotics.linkhelpers.commands.webrtc_teleop.webrtc_server"]
        try:
            self.service_proc = subprocess.Popen(launch_cmd, env=os.environ.copy())
            self.logger.info("Launched ASYNC WebRTC Server with pid: {} ... waiting to finish".format(self.service_proc.pid))
            self.service_proc.wait()
            self.logger.info('ASYNC WebRTC Server process {} has exited after {}s with code: {}'.format(
                self.service_proc.pid, time.time() - start_time, self.service_proc.returncode))
            self.service_proc = None
        except Exception as e:
            self.logger.error("Launching ASYNC WebRTC Server (cmd: {}) exception: {}".format(' '.join(launch_cmd), e))
        self.shutdown(reason='ASYNC WebRTC Server process ended')

    def set_up_peer_connection(self, command, topic, cmd_callback, settings):
        """
        This method will sent the offer to WebRTC Server trough CommLink SyncServer and then wait for an answer
        returning it
        """
        self.logger.info("Setting up peer connection")
        self.answer = None
        self.offer = command["data"]["offer"]
        self.topic = topic
        self.cmd_callback = cmd_callback

        self.logger.info("Requesting answer and peer connection")

        # Set the offer for the peer connection and return the answer
        self.comm_link_sync_server.send_message({"method": "get_answer_and_create_peer_connection", "command": command})

        start_time = time.time()

        while time.time() - start_time < 10:
            if self.answer is not None:
                break
            # do not remove the sleep bellow, it is preventing compiled code to hand in this loop for
            # the 10 seconds without giving the chance to SyncServer to do its work
            time.sleep(0.01)
        else:
            raise Exception("Did not get an answer from the WebRTC Server in the allocated time")

        self.is_peer_connection_open = True

        self.logger.info("Got answer and peer connection")
        self.comm_link_sync_server.send_message({"method": "update_settings", "settings": settings})

        return self.answer

    def set_answer(self, msg):
        """
        REMOTE CALL

        Called when an answer is available for the peer connection by the WebRTC Server
        """
        self.answer = msg['answer']

    def connection_lost(self, session, reason='unknown'):
        self.logger.info("Connection lost: {}".format(reason))
        self.close_peer_connection(reason, skip_async=True)

    def unregister_image_topic(self, session):
        """
        This method should be sent by WebRTC process just before closing a peer connection.
        It will unregister the image handler callback for the image topic,
        this way avoiding to use extra resources when not needed
        """
        # we need to make sure the session didn't change, as we don't want to unregister the handler for the new session
        # (this case is possible if a new connection is started before the previous one is closed)
        if self.link.webrtc_current_image_source and session and self.offer['teleop_session'] == session:
            self.link.unregister_image_topic_listener(self.link.webrtc_current_image_source, handle_image)
            self.logger.info("Unregistered image handler for session {}".format(session))

    def accepts_frame(self):
        """
        Check if enough time has passed since las frame, so max fps limit is respected
        :return:
        """
        if not self.is_peer_connection_open:
            return False
        now = time.time()
        self.last_received_frame_time = now
        elapsed = now - self.last_frame_time
        # maximum leniency is 50% is the expected frame delay.
        # so if 10fps, then delay is 100ms and max leniency 50ms
        max_leniency = self.min_frame_delay * .5

        if elapsed > self.min_frame_delay:
            # frame arrived late, so we increase leniency by the difference of
            # when it should have arrived vs when it actually arrived
            self.accept_frame_leniency += elapsed - self.min_frame_delay
        else:
            # frame arrived early, so we decrease the leniency by 10ms
            self.accept_frame_leniency -= 0.010
        # clamp leniency to 0..max_leniency
        self.accept_frame_leniency = max(0, min(max_leniency, self.accept_frame_leniency))
        return elapsed > self.min_frame_delay - self.accept_frame_leniency

    def frame_received_callback(self, link, topic, topic_type, np_array):
        """
        Link will send this each image we get
        """
        if not self.accepts_frame():
            return
        self.last_frame_time = time.time()
        try:

            if (self.shared_array_image is None or
                    np_array.dtype != self.shared_array_image.dtype or
                    np_array.shape != self.shared_array_image.shape):
                # Delete the old one if it exists
                try: 
                    SharedArray.delete("shm://teleop_video_frame")
                except: 
                    pass
                # Create our shared memory array
                self.shared_array_image = SharedArray.create("shm://teleop_video_frame", np_array.shape, np_array.dtype)
                self.logger.info("Created new shared array for image")

            # Throw it into shared memory
            np.copyto(self.shared_array_image, np_array)

            # Protect against shutdown issues
            if self.comm_link_sync_server is not None and self.comm_link_sync_server.is_connected():
                self.comm_link_sync_server.send_message({"method": "frame_available"})
        except Exception as e:
            self.on_error("Exception on frame_received_callback to webrtc: {}".format(e),
                          traceback.format_exc())

    def set_uploadable_topics(self, uploadable_topics, handle_topic):
        current_time = time.time()

        # unregistering topics which are not in the list any more

        topics_to_unregister = [
            topic
            for topic in self.uploadable_topics.keys()
            if topic not in uploadable_topics
        ]
        for topic in topics_to_unregister:
            self.uploadable_topics.pop(topic)
            self.logger.debug('Unregistering handler for topic {}.'.format(topic))
            self.link.unregister_topic_listener(topic, handle_topic)
    
        # updating all topics upload details
        for topic, min_update_delay in uploadable_topics.items():
            self.uploadable_topics[topic] = {
                'min_update_delay': min_update_delay,
                'last_update_time': current_time - min_update_delay,
                'callback': handle_topic,
            }
            # registering the listener
            self.link.register_topic_listener(topic, handle_topic)

        # saving the latest uploadable topics configuration on link side
        self.link.webrtc_uploadable_topics = self.uploadable_topics
        self.logger.info("Updated webrtc uploadable topics: {}".format(uploadable_topics))

    def unregister_uploadable_topics(self):
        for topic, details in self.uploadable_topics.items():
            self.link.unregister_topic_listener(topic, details.get('callback'))
        self.logger.debug("Unregistered previous uploadable topics listeners")

    def accepts_topic_update(self, topic_name):
        """
        Check if enough time has passed since last topic update
        :return:
        """
        if topic_name not in self.uploadable_topics:
            return False
        last_update_time = self.uploadable_topics[topic_name]['last_update_time']
        min_update_delay = self.uploadable_topics[topic_name]['min_update_delay']
        return time.time() - last_update_time > min_update_delay

    def topic_update_callback(self, topic_name, topic_type, platform, data, utc_time=None):
        """
        Link will send a topic_update message to ComLink Sync Server each time we have new data on the topic
        and update conditions are met
        """
        if not self.accepts_topic_update(topic_name):
            return
        self.uploadable_topics[topic_name]['last_update_time'] = time.time()
        if not self.comm_link_sync_server:
            # webrtc components are shutting down, let's keep quiet
            return
        try:
            self.comm_link_sync_server.send_message({
                "platform": platform,
                "method": "topic_update",
                "topic": topic_name,
                "type": topic_type,
                "data": replace_inf_nan_values(data),
                "utc_time": utc_time or time.time()
            })
        except Exception as e:
            self.on_error("Exception on topic_update_callback to webrtc: {}".format(e), traceback.format_exc())

    def received_link_command(self, msg):
        """
        RPC

        Returns a link command received through the webrtc connection
        back to the main process.
        """

        command = msg['command']
        now = time.time()
        self.logger.debug("Received link command with {}s delay over webrtc: {}".format(
            now - command.get('utc_time', 0),
            fastjson.dumps(command)))

        self.last_received_command_per_topic[command['topic']] = {
            'utc_secs': now,
            'command': command
        }

        try:
            self.cmd_callback(command)
        except Exception as e:
            # we should not allow an error processing a command to harm webrtc process/connection, so not shutting down
            self.logger.error("Exception on cmd callback over webrtc: {}".format(e))

    def received_webrtc_event(self, msg):
        """
        RPC
        Sends each webrtc event we receive back to the main process
        so we can decide what to do with it, such as errors, disconnects,
        and other issues.
        """
        pass

    def received_ping(self, msg):
        """
        This is a remote method that the webrtc server can call every little bit
        to check that we are still going. If this stops, then we know we need to 
        shut down the server
        """
        pass

    def on_error(self, error, trace=None):
        """
        For the WebRTC Server subprocess to communicate back 
        issues directly here so we can address them.
        """

        self.logger.fatal("\n\n")
        self.logger.fatal("################################################################################")
        self.logger.fatal("Error reported in WebRTC Server. Shutting Down")
        self.logger.fatal(str(error))
        self.logger.fatal(str(trace))
        self.logger.fatal("################################################################################\n\n")

        self.shutdown(reason=str(error))

    def close_peer_connection(self, reason, skip_async=False):
        self.logger.info("Triggering current peer connection close")

        self.is_peer_connection_open = False
        self.link.unregister_image_topic_listener(self.topic, self.frame_received_callback)
        self.logger.debug("Unregistered image listener")

        if getattr(self, 'comm_link_sync_server', None) is not None:
            if self.comm_link_sync_server.is_connected():
                if not reason:
                    reason = "unknown"
                reason += '(controller)'
                self.logger.debug("Sending WebRTC close peer connection message via CommLink")
                try:
                    if not skip_async:
                        self.comm_link_sync_server.send_message({"method": "close_peer_connection", "reason": reason})
                        self.logger.info("Sent WebRTC `close peer connection` message via CommLink")
                except Exception as e:
                    self.logger.warn("Could not send `close peer connection` message to WebRTC Server: {}".format(e))

        else:
            self.logger.warn("CommLink SyncServer is not up so, can not send `close peer connection` "
                             "message to WebRTC server!")


        self.unregister_uploadable_topics()

    def shutdown(self, msg=None, reason=None):
        """
        RPC or LOCAL

        Requests that the CommLink interface shuts down its communication
        after cleaning up as much of the WebRTC Interface as possible
        """

        if self.is_shutdown:
            return
        self.is_shutdown = True

        self.logger.info("Triggering shutdown of webrtc_server")

        if getattr(self, 'comm_link_sync_server', None) is not None:
            if self.comm_link_sync_server.is_connected():
                if not reason:
                    reason = "unknown"
                reason += '(controller)'
                self.logger.debug("Sending WebRTC shutdown message via CommLink")
                try:
                    self.comm_link_sync_server.send_message({"method": "shutdown", "reason": reason})
                    self.logger.info("Sent WebRTC `shutdown` message via CommLink")
                except Exception as e:
                    self.logger.warn("Could not send `shutdown` message to WebRTC Server: {}".format(e))

            try:
                self.comm_link_sync_server.close()
                self.logger.info("Disconnected CommLink SyncServer")
            except Exception as e:
                self.logger.error("Error closing from CommLink SyncServer: {}".format(e))
            finally:
                self.comm_link_sync_server = None
        else:
            self.logger.warn("CommLink SyncServer is not up, so can not send WebRTC shutdown command...")

        self.link.unregister_image_topic_listener(self.topic, self.frame_received_callback)
        self.logger.debug("Unregistered image listener")

        self.unregister_uploadable_topics()

        # Let the WebRTC Server cleanly close up before we hard kill it so we can
        # tell others in the browser what is going on
        kill_time = time.time()
        while time.time() - kill_time < 2:
            if self.service_proc is None:
                break
            time.sleep(0.01)
        else:
            try:
                self.service_proc.kill()
            except Exception as e:
                str_e = str(e)
                if 'No such process' not in str_e:
                    self.on_error(
                        "Could not kill webrtc subprocess with pid {}: {}".format(self.service_proc.pid, str(e)),
                        traceback.format_exc()
                    )
        self.link.webrtc_video_manager = None


class FakeLink:

    def __init__(self):
        pass

    def unregister_image_topic_listener(self, a, b):
        pass

    def register_image_topic_listener(self, a, b):
        pass


if __name__ == '__main__':

    try:
        system_commands.set_process_name("fr_webrtc_controller")

        link = FakeLink()
        webrtc_controller = WebRTC_Controller(link)
    except KeyboardInterrupt:
        print("Keyboard exit from WebRTC Controller")

    time.sleep(1)
    print("EVERYTHING IS CONNECTED AND WORKING!!!!! :-) ")
    time.sleep(10)

    webrtc_controller.shutdown(reason='Controller main code ending execution')
    time.sleep(1)
