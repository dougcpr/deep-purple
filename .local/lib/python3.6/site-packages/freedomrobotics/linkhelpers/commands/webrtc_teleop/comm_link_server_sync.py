import atexit
import threading
from multiprocessing.pool import ThreadPool
import socket

from freedomrobotics.helpers.jsonhelper import fastjson


class CommLinkServer:
    """
    This is the python 2.7 compatible synchronous code version of a wrapper around
    sockets to allow the WebRTC Controller to use this to talk with the WebRTC Server
    """
    def __init__(self, name, logger, port, message_callback, disconnect_callback=None):
        self.name = name
        self.logger = logger
        self.port = port
        self.message_callback = message_callback
        self.disconnect_callback = disconnect_callback

        self.socket = None
        self.conn = None
        self.is_closed = False

        atexit.register(self.close)

        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind(('localhost', self.port))
            self.logger.info("Server socket Bound")
            # Start listening for connections we can accept
            self.socket.listen(1)
            self.logger.info("Server socket listening")
        except:
            self.close()
            raise
        else:
            t = threading.Thread(target=self.listen_loop, name="comm_link_sync_server_loop")
            t.daemon = True
            t.start()

    def send_message(self, message={}):
        if not isinstance(message, dict):
            raise Exception("Can only send dictionary messages: " + str(type(message)))
        message = fastjson.dumps(message) + "\n"
        if self.conn is not None:
            try:
                self.conn.sendall(message.encode())
            except Exception as e:
                self.logger.error("Failed to send_message: {}".format(e))
                self.close()
        else:
            raise Exception("CommLink client is not connected so can not send a message to port " + str(self.port))

    def listen_loop(self):
        self.logger.info("Synchronous Server Listen Loop starting")
        pool = ThreadPool(processes=2)
        try:
            self.conn, addr = self.socket.accept()
            self.logger.info("Synchronous Server listener loop accepted connection from client.")
            while not self.is_closed:
                messages = self.conn.recv(1024*10).decode()
                if messages is None or len(messages) == 0:
                    self.logger.info("Remote connection disconnected")
                    self.close()
                    break
                for message in messages.split("\n"):
                    if len(message) == 0:
                        continue
                    try:
                        message = fastjson.loads(message)
                    except ValueError:
                        self.logger.warning("Non JSON message. Discarding: " + str(message))
                        continue
                    # This calls the message callback in a different thread so we can continue here
                    pool.apply_async(self.message_callback, args=(message,))
        except socket.error:
            pass
        except Exception as e:
            self.logger.error("Exception in server listener loop: {}".format(e))
        finally:
            pool.close()
            pool.join()
            self.close()

    def is_connected(self):
        return not self.is_closed and self.conn is not None

    def close(self):
        if self.is_closed is True:
            return

        self.is_closed = True

        if self.socket is not None:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
                self.socket.close()
                self.logger.info("    Closed CommLink Server socket")
            except Exception as e:
                self.logger.warn("Could not close CommLink Server socket: {}".format(e))
            finally:
                self.socket = None

        if self.conn is not None:
            try:
                self.conn.shutdown(socket.SHUT_RDWR)
                self.conn.close()
                self.logger.info("    Closed CommLink Server connection")
            except Exception as e:
                self.logger.warn("Could not close CommLink Server connection: {}".format(e))

            finally:
                self.conn = None

        if self.disconnect_callback is not None:
            try:
                self.disconnect_callback()
            except Exception as e:
                self.logger.debug("CommLink Server could not call disconnect_callback: {}".format(e))

        self.logger.info("Closed CommLink Server")
