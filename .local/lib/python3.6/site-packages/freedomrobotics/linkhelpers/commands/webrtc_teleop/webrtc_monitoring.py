import asyncio
import numpy as np
import sys
import SharedArray
import time

from collections import OrderedDict

from freedomrobotics.agenthelpers.measurements.measurement import Measurement
from freedomrobotics.helpers.jsonhelper import fastjson, round_float
from freedomrobotics.helpers.params import WEBRTC_STATS_SHARED_ARRAY_NAME
from freedomrobotics.helpers.report_error import report
from freedomrobotics.helpers.system_commands import execute


class WebRTCMeasurement(Measurement):

    def __init__(self, webrtc, pc, logger, credentials):
        Measurement.__init__(self, "webrtc", 30)
        self._should_shutdown = False
        self.pc = pc
        self.webrtc = webrtc
        self.logger = logger
        self.credentials = credentials

        self.data = OrderedDict()
        self.stats = {}
        self.freedom_video_frame_size = 0
        self.calculation_errors = 0

        self.sa_webrtc_stats_max_len = 4096
        self.sa_webrtc_stats_name = "shm://" + WEBRTC_STATS_SHARED_ARRAY_NAME
        self.sa_webrtc_stats = None

        if not self.disabled:
            asyncio.ensure_future(self.loop_measuring())
            asyncio.ensure_future(self.loop_reporting())
        asyncio.ensure_future(self.loop_shared_array_webrtc_stats_update())

    def is_shutdown(self):
        if not self._should_shutdown and self.webrtc.pc != self.pc:
            self.trigger_shutdown()
        return self._should_shutdown

    def trigger_shutdown(self):
        self._should_shutdown = True
        self.delete_sa_webrtc_stats()

    def delete_sa_webrtc_stats(self):
        try:
            SharedArray.delete(self.sa_webrtc_stats_name)
        except:
            pass

    def create_sa_webrtc_stats(self):
        self.delete_sa_webrtc_stats()
        self.sa_webrtc_stats = SharedArray.create(
            self.sa_webrtc_stats_name,
            (self.sa_webrtc_stats_max_len,),
            dtype=np.int8
        )
        self.logger.info("Created new shared array of size {} for webrtc stats".format(
            self.sa_webrtc_stats_max_len))

    def set_sa_webrtc_stats(self, array):
        if self.is_shutdown():
            return
        length = len(array)
        if length > self.sa_webrtc_stats_max_len:
            self.sa_webrtc_stats_max_len = int(length * 1.20)
            self.create_sa_webrtc_stats()
        if self.sa_webrtc_stats is None:
            self.create_sa_webrtc_stats()
        # we use first 2 elements in the shared array to indicate the size of the message array
        # and we fill with 0s the rest of the shared array
        np.copyto(self.sa_webrtc_stats,
                  [length // 128, length % 128] + array + [0] * (self.sa_webrtc_stats_max_len - length - 2))

    async def calculate_sa_webrtc_stats(self):
        now = time.time()
        messages = []
        response = {
            'utc_time': now,
            'webrtc_data_bytes_rate': None,
            'webrtc_data_latency_msecs': None,
            'webrtc_last_received_command_utc_secs': None,
            'webrtc_last_received_ping_utc_secs': None,
            'webrtc_last_video_frame_utc_sec': None,
            'webrtc_messages': [],
            'webrtc_state': self.pc.get_states(),
            'webrtc_video_bytes_rate': None,
            'webrtc_video_latency_msecs': None,
            'webrtc_video_settings': {
                'max_'+k: v for k, v in self.webrtc.settings.items()
                if k in ('width', 'height', 'fps')
            }
        }
        response['webrtc_video_settings']['max_bandwidth'] = self.webrtc.settings.get('max_bandwidth', 300) * 1024

        pc_stats = await self.get_pc_stats()
        video_in = None
        for k, v in pc_stats.items():
            if v.get('kind') == 'video':
                if 'inbound' in k:
                    video_in = v

        if not self.pc.last_ping_msg:
            messages.append('No pings from browser yet')
        else:
            response['webrtc_last_received_ping_utc_secs'] = self.pc.last_ping_time
            seconds_ago = now - self.pc.last_ping_time
            if seconds_ago > 5:
                messages.append('No pings from browser for the last {:.1f}s'.format(seconds_ago))

        if not self.webrtc.last_command_time:
            messages.append('No command from browser yet')
        else:
            response['webrtc_last_received_command_utc_secs'] = self.webrtc.last_command_time

        if not self.pc.web_rtl:
            messages.append('No report about RTL from browser')
        else:
            response['webrtc_data_latency_msecs'] = self.pc.web_rtl
            if self.pc.web_rtl > 1000:
                messages.append('High webrtc data latency')

        if not self.pc.web_video_bytes:
            messages.append('No report about video bytes rate from browser')
        else:
            response['webrtc_video_bytes_rate'] = self.pc.web_video_bytes * 1024

        if not self.pc.web_data_bytes:
            messages.append('No report about data bytes rate from browser')
        else:
            response['webrtc_data_bytes_rate'] = self.pc.web_data_bytes * 1024

        if video_in and 'roundTripTime' in video_in and isinstance(video_in['roundTripTime'], float):
            response['webrtc_video_latency_msecs'] = video_in['roundTripTime'] * 1000
            if video_in['roundTripTime'] > 1:
                messages.append('High webrtc video latency')
        else:
            messages.append('No details about video RTL yet')

        if (
            self.webrtc.freedom_video_stream
            and hasattr(self.webrtc.freedom_video_stream, 'current_frame')
            and self.webrtc.freedom_video_stream.last_received_frame_time
        ):
            response['webrtc_last_video_frame_utc_sec'] = \
                self.webrtc.freedom_video_stream.last_received_frame_time
            seconds_ago = now - self.webrtc.freedom_video_stream.last_received_frame_time
            if seconds_ago > 1:
                messages.append('No new video frames for the last {:.1f}s'.format(seconds_ago))
        else:
            messages.append('No video frames sent yet using webrtc')

        response['webrtc_messages'] = messages
        # self.logger.info(response)
        return response

    def compute(self, agent=None):
        self.clean_data(self.data)
        try:
            self.calculate_stats()
            self.calculation_errors = 0
        except Exception as e:
            # as pc stats does not have all attributes from the beginning
            # there are cases where some exceptions might happen while calculating stats immediately after
            # the peer connection is started
            if self.calculation_errors < 10:
                self.logger.info("Temporary error in WebRTC measurement compute: {}".format(e))
                self.calculation_errors += 1
            else:
                report(
                    "Error in WebRTC measurement compute: {}".format(e),
                    self.credentials,
                    [],
                    sys.exc_info(),
                    code='FRA_WEBRTC_MEASURE_COMPUTE')
                raise
        # self.logger.info(fastjson.dumps(self.stats, indent=4))
        return {
            "system.webrtc": self.stats
        }

    def clean_data(self, data, max_old=None):
        if not max_old:
            max_old = self.interval
        now = time.time()
        samples_time = list(data.keys())
        # we do not remove last element from outside the interval
        for i, k in enumerate(samples_time[:-1]):
            if now - samples_time[i+1] > max_old:
                data.pop(k)
            else:
                break

    async def get_pc_stats(self):
        return details_to_dict(await self.pc.getStats())

    async def get_data(self):
        now = time.time()
        data = await self.get_pc_stats()
        current_frame = getattr(self.webrtc.freedom_video_stream, 'current_frame', None)
        if self.webrtc.freedom_video_stream and current_frame:
            w = self.webrtc.freedom_video_stream.current_frame.width
            h = self.webrtc.freedom_video_stream.current_frame.height
            # /8 bits to bytes,
            # /9 is an approximation of the compression as observed live
            frame_size = w * h * 24 / 8 / 9
            if abs(self.freedom_video_frame_size - frame_size) > 0.2 * self.freedom_video_frame_size:
                self.webrtc.logger.debug(
                    'Video frame {}x{} has an approximated size of ~{:.0f}kB'.format(w, h, frame_size / 1024))
                self.freedom_video_frame_size = frame_size
            data['frame_size'] = frame_size
        if self.pc.web_rtl:
            data['webRTL'] = self.pc.web_rtl
        if self.pc.web_video_bytes:
            data['webVideoBytes'] = self.pc.web_video_bytes
        if self.pc.web_data_bytes:
            data['webDataBytes'] = self.pc.web_data_bytes
        self.data[now] = data

    def calculate_stats(self):
        # we use rate_keys for values that are expected to increment, and we calculate the rate out of it
        # we use just _keys for values that can go up and down in time
        # we don't need to calculate the rate for the last ones
        transport_rate_keys = {'bytesSent', 'bytesReceived', 'packetsSent', 'packetsReceived'}
        other_keys = {'webRTL', 'webDataBytes'}
        video_keys = {'roundTripTime'}
        video_rate_keys = {'bytesSent', 'packetsSent', 'packetsLost'}
        other_video_keys = {'frame_size', 'webVideoBytes'}
        first_stat = None
        last_stat = None
        prev_stat = None
        stat = {'max': {'video': {}}, 'avg': {'video': {}}}
        # calculating max stats
        for sample_time, pc_stat in self.data.copy().items():
            if prev_stat:
                for k1, v in pc_stat.items():
                    if k1 in other_video_keys:
                        stat['max']['video'][k1] = round_float(
                            max(stat['max']['video'].get(k1, 0), pc_stat[k1]))
                    if k1 in other_keys:
                        stat['max'][k1] = round_float(max(stat['max'].get(k1, 0), pc_stat[k1]))
                    if not isinstance(v, dict):
                        continue
                    if v.get('type') == 'transport' and k1 in prev_stat[1]:
                        for k2 in transport_rate_keys:
                            if k2 in v and k1 in prev_stat[1] and k2 in prev_stat[1][k1]:
                                rate = round_float((pc_stat[k1][k2] - prev_stat[1][k1][k2]) /
                                                   (sample_time - prev_stat[0]))
                                if k2 not in stat['max'] or stat['max'][k2] < rate:
                                    stat['max'][k2] = rate
                    if v.get('kind') == 'video':
                        for k2 in video_rate_keys:
                            if k2 in v and k1 in prev_stat[1] and k2 in prev_stat[1][k1]:
                                rate = round_float((pc_stat[k1][k2] - prev_stat[1][k1][k2]) /
                                                   (sample_time - prev_stat[0]))
                                if k2 not in stat['max']['video'] or stat['max']['video'][k2] < rate:
                                    stat['max']['video'][k2] = rate
                        for k2 in video_keys:
                            if k2 in v:
                                stat['max']['video'][k2] = round_float(
                                    max(pc_stat[k1][k2], stat['max']['video'].get(k2, 0)))
            prev_stat = (sample_time, pc_stat)
            if not first_stat:
                first_stat = (sample_time, pc_stat)
                for k1, v in pc_stat.items():
                    if k1 in other_video_keys:
                        stat['max']['video'][k1] = round_float(pc_stat[k1])
                    if k1 in other_keys:
                        stat['max'][k1] = round_float(pc_stat[k1])
                    if not isinstance(v, dict):
                        continue
                    if v.get('kind') == 'video':
                        for k2 in video_keys:
                            if k2 in v:
                                stat['max']['video'][k2] = round_float(pc_stat[k1][k2])
            else:
                last_stat = (sample_time, pc_stat)
        # calculating average rates
        if first_stat and last_stat:
            for k1, v in last_stat[1].items():
                if not isinstance(v, dict) or k1 not in first_stat[1]:
                        continue
                if v.get('type') == 'transport':
                    for k2 in transport_rate_keys:
                        if k2 in v and k2 in first_stat[1][k1]:
                            stat['avg'][k2] = round_float((last_stat[1][k1][k2] - first_stat[1][k1][k2]) /
                                                          (last_stat[0] - first_stat[0]))
                if v.get('kind', None) == 'video':
                    for k2 in video_rate_keys:
                        if k2 in v and k2 in first_stat[1][k1]:
                            stat['avg']['video'][k2] = round_float((last_stat[1][k1][k2] - first_stat[1][k1][k2]) /
                                                                   (last_stat[0] - first_stat[0]))
                # for oscillating attributes (non incremental)
                seconds = last_stat[0] - first_stat[0]
                for k1 in (other_video_keys | other_keys):
                    if k1 not in first_stat[1] or k1 not in last_stat[1]:
                        continue
                    avg = 0
                    for sample_time, raw_stat in self.data.copy().items():
                        if k1 not in raw_stat:
                            continue
                        current_value = raw_stat[k1]
                        if sample_time != first_stat[0]:
                            avg += (last_value + current_value) / 2 * (sample_time - last_timestamp)
                        last_value = current_value
                        last_timestamp = sample_time
                    if k1 in other_video_keys:
                        stat['avg']['video'][k1] = round_float(avg / seconds)
                    else:
                        stat['avg'][k1] = round_float(avg / seconds)
        self.stats = stat

    async def loop_shared_array_webrtc_stats_update(self):
        while not self.is_shutdown() and not self.webrtc.is_shutdown():
            await asyncio.sleep(1)
            try:
                self.set_sa_webrtc_stats(
                    list(fastjson.dumps(await self.calculate_sa_webrtc_stats()).encode('utf-8')))
            except (SystemExit, KeyboardInterrupt) as e:
                self.webrtc.shutdown(reason=str(e))
                return
            except Exception as e:
                self.delete_sa_webrtc_stats()
                report(
                    "Error in WebRTC shared array stats update loop: {}".format(e),
                    self.credentials,
                    [],
                    sys.exc_info(),
                    code='FRA_WEBRTC_MEASURE_LOOP')
                raise
        self.delete_sa_webrtc_stats()

    async def loop_measuring(self):
        while not self.is_shutdown() and not self.webrtc.is_shutdown():
            await asyncio.sleep(5)
            try:
                await self.get_data()
            except (SystemExit, KeyboardInterrupt) as e:
                self.webrtc.shutdown(reason=str(e))
                return
            except Exception as e:
                report(
                    "Error in WebRTC measuring loop: {}".format(e),
                    self.credentials,
                    [],
                    sys.exc_info(),
                    code='FRA_WEBRTC_MEASURE_LOOP')
                raise

    async def loop_reporting(self):
        try:
            hostname = execute("hostname")
            while not self.is_shutdown() and not self.webrtc.is_shutdown():
                await asyncio.sleep(10)
                result = self.update(None)
                if not result:
                    continue
                self.webrtc.message(topic=None,
                                    topic_type='system_measurements',
                                    data={"hostname": hostname, "measurements": result},
                                    platform='mission_control_controller',
                                    utc_time=time.time())
        except (SystemExit, KeyboardInterrupt) as e:
            self.webrtc.shutdown(reason=str(e))
            return
        except Exception as e:
            report("Error in WebRTC measurement reporting loop: {}".format(e), self.credentials, [], sys.exc_info(),
                   code='FRA_WEBRTC_MEASURE_REPORT_LOOP')
            raise


def details_to_dict(d):
    if isinstance(d, (int, float)):
        return d
    if isinstance(d, (list, set)):
        na = []
        for v in d:
            na.append(details_to_dict(v))
        return na
    if isinstance(d, dict):
        nd = {}
        for k, v in d.items():
            nd[k] = details_to_dict(v)
        return nd
    else:
        if hasattr(d, "__dict__"):
            return details_to_dict(d.__dict__)
        else:
            return str(d)
