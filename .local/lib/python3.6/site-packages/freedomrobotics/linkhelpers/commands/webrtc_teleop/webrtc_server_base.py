#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright (C) Freedom Robotics, 2019 - All Rights Reserved

This file is part of the the Freedom Python SDK

Unauthorized copying of this file, via any medium is strictly prohibited
Proprietary and confidential
"""

"""
This is the Python3-only implementation of WebRTC Video and data control.
It uses Asyncio as part of aoirtc, which is only supported in python3.
Therefore, we treat it as a separate application which is run in a different
process and communicated with over sockets.

Key implementation detail - everything is asyncronous for how this works,
so you need to use async (asynio.corutine), await (await) and other python3 ideas.

"""

import sys
import os
import time
import asyncio
import SharedArray

from aiortc import RTCPeerConnection as aiortcRTCPeerConnection, RTCSessionDescription
import aiortc.codecs.vpx
from aiortc.contrib.media import MediaPlayer
from concurrent.futures import ThreadPoolExecutor

from freedomrobotics.helpers import credentials as credentials_helper
from freedomrobotics.helpers.logging_helpers import setup_logging
from freedomrobotics.helpers.jsonhelper import fastjson
from freedomrobotics.helpers.report_error import report
from freedomrobotics.linkhelpers.commands.webrtc_teleop.freedom_video_stream import FreedomVideoStream
from freedomrobotics.linkhelpers.commands.webrtc_teleop.comm_link_client_async import CommLinkClient
from freedomrobotics.linkhelpers.commands.webrtc_teleop.webrtc_controller import COMM_LINK_SERVER_PORT, ALLOWED_COMMANDS_TYPES
from freedomrobotics.linkhelpers.commands.webrtc_teleop.webrtc_monitoring import WebRTCMeasurement
from freedomrobotics.link_base import LinkLock, LinkUploader

loaded_credentials = credentials_helper.load()
logger = setup_logging(
    name=__name__,
    log_path=os.path.join(loaded_credentials[1], 'logs', 'webrtc_async.log'),
    log_level=loaded_credentials[0].get('log_level').upper(),
    log_format="%(asctime)s [ASYNC] [%(process)5d] [%(levelname)-5.5s]  %(message)s",
    console=False,
)

if sys.version_info < (3, 6):
    raise Exception("This module must be run in Python3.6+")

loop = asyncio.get_event_loop()
executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix='webrtc_base_executor')

# Make the default bitrate 70% of max to give the stream a "soft start"
DEFAULT_BITRATE_RATIO = 0.7


class RTCPeerConnection(aiortcRTCPeerConnection):
    """
    Extending aiortc RTCPeerConnection interface
    """
    def __init__(self, session_id=None, configuration=None):
        super().__init__(configuration=configuration)
        self.__session_id = session_id if session_id else self.__stream_id[:8]
        self.__last_state_change = time.time()
        self.__last_states = None
        self.last_ping_time = time.time()
        self.last_ping_msg = {}
        self.web_rtl = None  # round trip latency as reported by browsers via ping
        self.web_video_bytes = None  # bytes rate on media stream as reported by browsers via ping
        self.web_data_bytes = None  # bytes rate on data channels as reported by browsers via ping
        self.save_states()

    @property
    def session_id(self):
        return self.__session_id

    def is_closed(self):
        return self.__isClosed

    def get_states(self):
        return {
            'signaling': self.signalingState,
            'ice_gathering': self.iceGatheringState,
            'ice_connection': self.iceConnectionState,
        }

    def save_states(self):
        self.__last_state_change = time.time()
        self.__last_states = self.get_states()

    def get_previous_states_details(self):
        return {
            'previous_states': self.__last_states,
            'time_passed_in_previous_state': time.time() - self.__last_state_change,
            'session': self.session_id,
            'pid': os.getpid()
        }


class WebRTCServer(LinkUploader, LinkLock):
    """
    This is the actual WebRTC process

    """

    def __init__(self):
        """
        Initializes comm link client and connects to the already-running
        controller server which will talk to this.

        Separately, the get_answer_and_Create_peer_connection 
        needs to be called to do all the heavy lifting.

        """
        super(WebRTCServer, self).__init__('webrtc_server', logger=logger)

        self.shared_image_array = None
        self.freedom_media_player = None
        self.freedom_video_stream = None
        self.freedom_video_frame_size = 0
        self.pc = None
        self.last_command_time = None
        self.is_peer_connection_open = False
        self.last_pong_time = time.time()
        self.topics_channels = {}
        self.settings = {}

        logger.info("Creating CommLink ASyncClient")
        self.comm_link_async_client = CommLinkClient(
            "CommLink ASyncClient {}".format(os.getpid()),
            logger,
            COMM_LINK_SERVER_PORT,
            self.controller_message_callback,
            self.controller_disconnect_callback)

    def set_rtc_bitrate(self, max_bandwidth, max_fps):
        # if using direct video source, for some reason bitrate is
        # increased exactly tenfold, so divide it by 10 here
        bitrate_factor = 0.1 if self.freedom_media_player else 1.0
        # bandwidth in the app is expressed in KB/s, but aiortc expects bits per second,
        # so *8 to get to kilobits per second, *1000 to get to bits per second
        bitrate = int(max_bandwidth * 8 * 1000 * bitrate_factor)
        # minimum bitrate is 5KB/s
        min_bitrate = int(5 * 8 * 1000 * bitrate_factor)
        # default is a bit less than max as to give the video stream a "soft start"
        aiortc.codecs.vpx.DEFAULT_BITRATE = int(bitrate * DEFAULT_BITRATE_RATIO)
        aiortc.codecs.vpx.MIN_BITRATE = min_bitrate
        aiortc.codecs.vpx.MAX_BITRATE = bitrate
        aiortc.codecs.vpx.MAX_FRAME_RATE = int(max_fps)

    def update_settings(self, settings):
        if settings:
            logger.info('Updating webrtc settings: {}'.format(settings))
            self.settings.update(settings)
            fps = self.settings.get('max_fps')
            self.set_rtc_bitrate(settings['max_bandwidth'], fps)
            loop.create_task(
                self.comm_link_async_client.send_message({'method': 'update_fps', 'fps': fps})
            )

    async def controller_message_callback(self, msg):

        if 'method' not in msg:
            raise Exception("Received a message from the controller without a `method` element: " + fastjson.dumps(msg))

        if msg['method'] == 'topic_update':
            await self.topic_update(msg)
        elif msg['method'] == 'frame_available':
            if self.is_peer_connection_open:
                await self.frame_available()
        elif msg['method'] == 'close_peer_connection':
            await self.close_peer_connection(self.pc, reason='Triggered via ComLink: {}'.format(msg.get('reason')))
        elif msg['method'] == 'shutdown':
            await self.shutdown(reason='Triggered via ComLink: {}'.format(msg.get('reason')))
        elif msg['method'] == 'ping':
            # Let them ping us to see if we are still around
            pass
        elif msg['method'] == 'update_settings':
            self.update_settings(msg.get('settings', {}))
        elif msg['method'] == 'get_answer_and_create_peer_connection':
            await self.get_answer_and_create_peer_connection(msg)
        else:
            raise Exception("Unknown message from controller: " + fastjson.dumps(msg))

    async def controller_disconnect_callback(self, reason='unknown'):
        """
        Method called when CommLink ASyncClient closes connection to CommLink SyncServer or was closed
        :return:
        """
        await self.shutdown(reason='CommLink ASyncClient disconnected from SyncServer: {}'.format(reason))

    async def get_answer_and_create_peer_connection(self, msg):
        """
        Link got an offer to open a webrtc connection and passed us the offer.
        This method then passes back the answer to that offer from our local webrtc server, so that it can be sent
        back to the remote one.
        """
        start_time = time.time()
        logger.info("Started async_get_answer_and_create_peer_connection")
        logger.info(fastjson.dumps(msg, indent=4))
        self.settings['direct_video_source'] = msg['command']["data"].get("direct_video_source", None)
        offer = msg["command"]["data"]["offer"]

        self.set_rtc_bitrate(msg["command"]["data"]['max_bandwidth'], int(msg["command"]["data"]['max_fps']))

        if not isinstance(offer, dict) or 'sdp' not in offer:
            raise Exception("WebRTC Offer must be a dictionary including 'sdp'.")

        try:
            answer = await self.peer_connection(offer)
            self.is_peer_connection_open = True
            logger.debug('Prepared answer: {}'.format(answer))
            now = time.time()
            msg_data = {
                "command_received": msg["command"],
                "result": {
                    "answer": answer,
                    "execution_time": round(now - start_time, 3),
                    "success": True
                }
            }
            self._queue_message(
                topic=None,
                topic_type='command_completed',
                data=msg_data,
                platform='mission_control_link',
                current_time=round(now, 2),
                urgent=True)

            await self.comm_link_async_client.send_message({"method": "set_answer", "answer": answer})

            return answer

        except Exception as e:
            log_msg = "Exception in get_answer_and_create_peer_connection: {}".format(e)
            self.logger.exception(log_msg)
            await self.shutdown(reason=log_msg)

    async def frame_available(self):
        """
        Called by Link each time a new frame is available for
        the selected topic. This method will then read shared memory
        to access the image
        """

        if self.freedom_media_player:
            # ignore ros frames if media player is on.
            return

        try:
            # if self.shared_image_array is None:
            #     self.shared_image_array = SharedArray.attach("shm://teleop_video_frame")
            np_array = SharedArray.attach("shm://teleop_video_frame")
            if self.freedom_video_stream is not None:
                # logger.debug("Received new frame and saving it to VideoFrameStream.")
                self.freedom_video_stream.set_image(np_array)
        except Exception as e:
            log_msg = "Exception in WebRTCServer.frame_available: {}".format(e)
            self.logger.exception(log_msg)
            await self.shutdown(reason=log_msg)

    async def topic_update(self, message):
        """
        Called by Link each time a new message is available for the selected topic.
        It mainly passes the message to webrtc data channel.
        """
        if not hasattr(self, 'channel'):
            # data channel was not yet initiated, let's be quiet for now.
            return
        message.pop('method')  # Used by webrtc components internally, no need to send

        topic = message.get('topic')
        if topic:
            if topic in self.topics_channels.keys():
                channel = self.topics_channels[topic]
            else:
                channel = self.pc.createDataChannel(topic)
                logger.info('Created new data channel for topic: {}.'.format(topic))
                self.topics_channels[topic] = channel
        else:
            # failing over to commands data channel (initiated on browser side)
            channel = self.channel

        if channel.readyState != "open":
            logger.debug('Channel for topic {} is not open yet'.format(topic))
            return

        if channel.bufferedAmount > 0:
            # this way we do not clog the data channel, allowing messages
            # to arrive with minimum delay at the cost of losing some of them
            logger.debug("Data channel '{}' buffer is {}, not sending this message: {}".format(
                channel.label, channel.bufferedAmount, message))
            return

        try:
            msg = fastjson.dumps(message)
            logger.debug("Sending message via {} data channel: {}".format(channel.label, msg))
            channel.send(msg)
        except Exception as e:
            log_msg = "Exception in WebRTCServer.topic_update: {}".format(e)
            self.logger.exception(log_msg)
            await self.shutdown(reason=log_msg)

    async def connection_lost(self, pc, reason=None):
        await self.close_peer_connection(pc, reason)
        await self.comm_link_async_client.send_message(
            {'method': 'connection_lost', 'session': pc.session_id, 'reason': reason})

    async def timeout_shutdown(self):
        await self.shutdown("Process timed out with no remote connections.")

    def check_timeout_shutdown(self):
        # 90s have passed since a peer disconnected. if no one has connected in this time,
        # shut down the webrtc process
        if not self.pc or not self.is_peer_connection_open:
            loop.create_task(self.timeout_shutdown())

    async def close_peer_connection(self, pc, reason=None, shutdown=False):
        if not pc:
            return
        self.is_peer_connection_open = False
        pc.measurement.trigger_shutdown()
        # a peer just diconnect, so
        # call this function in 90 seconds to check if we should shutdown
        loop.call_later(90, self.check_timeout_shutdown)
        if not pc.is_closed():
            if not reason:
                reason = 'unknown'
            logger.info("Closing WebRTC peer connection {}, reason: {}".format(pc.session_id, reason))
            pc_stats = await pc.measurement.get_pc_stats()
            report_level = 'info' if pc.iceConnectionState in ('closed', 'completed') else 'warning'
            report_msg = 'WebRTC peer connection {} closed from state {}, reason: {}'.format(
                pc.session_id, pc.get_states(), reason)
            report_details = [pc_stats, pc.get_previous_states_details(), pc.measurement.stats]
            report_kwargs = {
                'code': 'FRA_WEBRTC_SHUT_DOWN',
                'level': report_level,
                'logs': fastjson.dumps(
                    report_details,
                    indent=4).split('\n')
            }
            await self.comm_link_async_client.send_message(
                {'method': 'unregister_image_topic', 'session': pc.session_id})
            if shutdown:
                report(report_msg, loaded_credentials[0], **report_kwargs)
            else:
                executor.submit(report, report_msg, loaded_credentials[0], **report_kwargs)
            getattr(self.logger, report_level)('{}: {}'.format(report_msg, report_details))

            await pc.close()

    async def shutdown(self, reason=None):
        """
        Called by Link if we need to shut down the WebRTC connection,
        clean up threads, etc to exit
        """
        if self._should_shutdown:
            return
        self._should_shutdown = True
        if not reason:
            reason = 'unknown'
        await self.close_peer_connection(self.pc, reason=reason, shutdown=True)
        logger.info("Shutting down WebRTC Server, reason: {}".format(reason))
        self.comm_link_async_client.close()
        if self.pc:
            self.pc.measurement.trigger_shutdown()

    async def peer_connection(self, params):
        offer = RTCSessionDescription(
            sdp=params['sdp'],
            type=params['type']
        )
        logger.debug("Here is the WebRTC SDP Offer:\n{}".format(offer.sdp.replace('\\r\\n', '\n')))

        pc = RTCPeerConnection(session_id=params.get('teleop_session'))
        self.pc = pc
        pc.measurement = WebRTCMeasurement(self, pc, logger, loaded_credentials[0])

        async def on_iceconnectionstatechange():
            try:
                pc.last_ping_time = time.time()
                self.logger.info(
                    'ICE connection state for session {} changed to: {}: {}'.format(
                        pc.session_id, pc.iceConnectionState, pc.get_previous_states_details()))
                if pc.iceConnectionState in ('failed', 'closed'):
                    pc.measurement.trigger_shutdown()
                    await self.close_peer_connection(pc, reason='ICE connection state changed to: {}'
                                                                ''.format(pc.iceConnectionState))
                elif pc.iceConnectionState in ('completed', ):
                    if hasattr(self.freedom_video_stream, 'set_assistance_params'):
                        self.freedom_video_stream.set_assistance_params(delay=1, fps=4)
                # if connection state changes to "disconnected" because of temporary network issues,
                # it is possible to recover itself
            except Exception as e:
                self.logger.error(">>>>>>>> Exception in on_iceconnectionstatechange: {}".format(e))
            pc.save_states()
        pc.on('iceconnectionstatechange', on_iceconnectionstatechange)

        async def on_icegatheringstatechange():
            try:
                pc.last_ping_time = time.time()
                self.logger.info(
                    'ICE gathering state for session {} changed to: {}: {}'.format(
                        pc.session_id, pc.iceGatheringState, pc.get_previous_states_details()))
            # if pc.iceConnectionState == 'failed':
            #    await pc.close()
            except Exception as e:
                self.logger.error(">>>>>>>> Exception in on_icegatheringstatechange: {}".format(e))
            pc.save_states()
        pc.on('icegatheringstatechange', on_icegatheringstatechange)

        def on_track(track):
            try:
                logger.info("PEER CONNECTION: Track: " + str(track))
            except Exception as e:
                self.logger.error(">>>>>>>> Exception in on_track " + str(e))
        pc.on('track', on_track)

        def on_signalingstatechange():
            try:
                pc.last_ping_time = time.time()
                self.logger.info(
                    'PEER connection signaling state for session {} changed to: {}: {}'.format(
                        pc.session_id, pc.signalingState, pc.get_previous_states_details()))
            except Exception as e:
                self.logger.error(">>>>>>>> Exception in on_signalingstatechange: {}".format(e))
            pc.save_states()
        pc.on('signalingstatechange', on_signalingstatechange)

        def on_datachannel(channel):
            self.channel = channel
            logger.info('Got a data channel ' + channel.label + ', created by remote party')

            def on_message(message):
                logger.debug('data channel message: ' + channel.label + ' < ' + message)
                try:
                    msg = fastjson.loads(message)
                    msg_type = msg.get('type')
                    if msg_type is None:
                        # for each message we send on one of the fast uploadable topics, we will receive back
                        # an empty dict message; this unclogs the datachannel :o !?!
                        pass
                    elif msg_type in ALLOWED_COMMANDS_TYPES:
                        self.last_command_time = msg.get('utc_time', time.time())
                        loop.create_task(
                            self.comm_link_async_client.send_message(
                                {'method': 'received_link_command', 'command': msg}))
                    elif msg_type == 'freedom_msgs/Ping':
                        now = time.time()
                        if now - self.last_pong_time < 0.5:
                            return
                        pc.last_ping_msg = msg
                        pc.last_ping_time = time.time()
                        msg['utc_server_secs'] = pc.last_ping_time
                        msg['type'] = 'freedom_msgs/Pong'
                        # logger.info(fastjson.dumps(msg, indent=4))
                        message_details = msg.get('message', {})
                        if 'rtl' in message_details:
                            pc.web_rtl = message_details['rtl']
                        if 'video_bytes_rate' in message_details:
                            pc.web_video_bytes = message_details['video_bytes_rate']
                        if 'data_bytes_rate' in message_details:
                            pc.web_data_bytes = message_details['data_bytes_rate']
                        logger.debug({'event_type': 'WEBRTC_AGENT_RECEIVED_PING'})
                        logger.debug("Sending a pong response at {}, back to browser for the ping "
                                     "with uid: {}, from: {} (browser side)".format(
                                        msg['utc_server_secs'], msg.get('uid'), msg.get('utc_ping_secs')))
                        channel.send(fastjson.dumps(msg))
                        self.last_pong_time = now
                        logger.debug({'one_way_latency': msg['utc_server_secs'] - float(msg.get('utc_ping_secs') or 0)})
                    else:
                        logger.warning('Received a `{}` type command. Ignoring it: {}'.format(msg_type, msg))
                except Exception as e:
                    self.logger.exception('Exception in datachannel message handler: {}'.format(e))
                    raise e
            channel.on('message', on_message)

            async def monitor_datachannel():
                while True:
                    if channel.transport.transport.state in ["closed", "failed"]:
                        await self.connection_lost(pc, reason='Datachannel closed')
                        return
                    await asyncio.sleep(0.1)

            asyncio.ensure_future(monitor_datachannel())

        pc.on('datachannel', on_datachannel)

        await pc.setRemoteDescription(offer)

        logger.info("Adding transceivers")

        direct_video_source = self.settings.get('direct_video_source', None)
        bandwidth = self.settings.get('max_bandwidth', 100)
        resolution = self.settings.get('max_video_resolution', None)
        fps = self.settings.get('max_fps', '10')

        if direct_video_source:
            if not resolution or len(resolution.split(',')) != 2:
                resolution = "320x240"
            else:
                w, h = resolution.split(',')
                resolution = f'{w}x{h}'
            options = {"framerate": str(fps), "video_size": resolution}
            logger.info("Using direct video source: " + str(direct_video_source))
            source_format = "v4l2"
            if direct_video_source.startswith('rtsp://'):
                source_format = 'rtsp'
            self.freedom_media_player = MediaPlayer(direct_video_source, format=source_format, options=options)
            self.set_rtc_bitrate(bandwidth, fps)
            self.freedom_video_stream = self.freedom_media_player.video
        else:
            logger.info("Using ros topic as source")
            self.freedom_media_player = None
            self.set_rtc_bitrate(bandwidth, fps)
            self.freedom_video_stream = FreedomVideoStream(logger=logger, settings=self.settings)

        for t in pc.getTransceivers():
            logger.info("Adding transceiver:" + str(t.kind))
            if t.kind == 'video':
                logger.info("Adding PeerConnection video track")
                pc.addTrack(self.freedom_video_stream)

        answer = await pc.createAnswer()
        logger.debug("Here is the WebRTC SDP Answer:\n{}".format(answer.sdp.replace('\\r\\n', '\n')))
        await pc.setLocalDescription(answer)

        return {
            'sdp': pc.localDescription.sdp,
            'type': pc.localDescription.type
        }

    def on(self, event):
        def wrap(fn):
            if event == 'cmd':
                self.cmd_fn = fn
        
        return wrap        


async def main():

    logger.info("WebRTC Server Creation Async start")
    webrtc_server = WebRTCServer()

    start_time = time.time()
    max_comm_link_connection_time = 15
    logger.debug("Waiting up to {} seconds for CommLink ASyncClient in WebRTC Server to connect to "
                 "CommLink SyncServer.".format(max_comm_link_connection_time))
    while not webrtc_server.is_shutdown() and \
            not webrtc_server.comm_link_async_client.is_connected() and \
            time.time() - start_time < max_comm_link_connection_time:
        await asyncio.sleep(1.0)

    if not webrtc_server.comm_link_async_client.is_connected():
        logger.fatal("CommLink ASyncClient process could not connect to CommLink SyncServer after {} seconds. "
                     "Exiting.".format(max_comm_link_connection_time))
        await webrtc_server.shutdown(reason='CommLink ASyncClient process could not connect to CommLink SyncServer')

    if not webrtc_server.is_shutdown():
        logger.info("WebRTC Server is started and CommLink ASyncClient connected to CommLink SyncServer")

    consecutive_failures, max_consecutive_failures, retry_interval = 0, 30, 0.1
    while not webrtc_server.is_shutdown():
        try:
            # Ping it every little bit to make sure we are still alive
            # This is a ping between python3 process and python2 process,
            # this does not go to the app. It just checks if it's still connected
            # to the python process that started webRTC.
            await webrtc_server.comm_link_async_client.send_message({"method": "ping"})
            consecutive_failures = 0
        except Exception as e:
            if consecutive_failures == 0:
                logger.exception("Could not ping CommLink SyncServer")
            consecutive_failures += 1
            if consecutive_failures >= max_consecutive_failures:
                logger.fatal("Could not ping CommLink SyncServer for more than {}s, "
                             "so shutting down WebRTC server".format(consecutive_failures*retry_interval))
                await webrtc_server.shutdown(reason='Could not ping CommLink SyncServer for more than {}s'
                                                    ''.format(consecutive_failures*retry_interval))
        max_no_ping_time = webrtc_server.settings.get('max_time_no_browser_ping', 35)
        if webrtc_server.pc and not webrtc_server.pc.is_closed() and \
                time.time() - webrtc_server.pc.last_ping_time > max_no_ping_time:
            await webrtc_server.connection_lost(
                webrtc_server.pc,
                reason='Did not received any pings from browser for more '
                       'than {}s'.format(max_no_ping_time))
        await asyncio.sleep(retry_interval)
